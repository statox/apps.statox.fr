class a extends Error{constructor(){super("Tried to divide by 0")}}class b extends Error{constructor(t){super("Expected a number, instead got",t)}}const h=e=>{if(typeof e!="number"||!Number.isFinite(e))throw new b(e);return e},m=(e,t,r)=>(h(e),h(t),h(r),Math.min(Math.max(e,t),r)),u=e=>e!==null&&typeof e=="object"&&"x"in e&&"y"in e&&typeof e.x=="number"&&typeof e.y=="number";class o{x=0;y=0;constructor(t=0,r=0){if(!Number.isFinite(t))throw new TypeError("The x argument should be a number");if(!Number.isFinite(r))throw new TypeError("The y argument should be a number");this.x=t,this.y=r}static fromArray=t=>{if(t.length<2)throw new TypeError("The length of the argument array must be at least 2");if(!Number.isFinite(t[0])||!Number.isFinite(t[1]))throw new TypeError("The members of the argument array must be numbers");return new o(t[0],t[1])};static fromObject=t=>{if(!Number.isFinite(t.x))throw new TypeError("The .x property of the argument object must be a number");if(!Number.isFinite(t.y))throw new TypeError("The .y property of the argument object must be a number");return new o(t.x,t.y)};static fromPolar=(t,r)=>{if(!Number.isFinite(t))throw new TypeError("The radians argument must be a number");if(!Number.isFinite(r))throw new TypeError("The magnitude argument must be a number");return new o(r*Math.cos(t),r*Math.sin(t))};static randomUnitVector=()=>new o(1,0).rotateBy(Math.random()*2*Math.PI);addX(t){return this.x+=t.x,this}addY(t){return this.y+=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addScalarX(t){return this.x+=t,this}addScalarY(t){return this.y+=t,this}subtractX(t){return this.x-=t.x,this}subtractY(t){return this.y-=t.y,this}subtract(t){return this.x-=t.x,this.y-=t.y,this}subtractScalar(t){return this.x-=t,this.y-=t,this}subtractScalarX(t){return this.x-=t,this}subtractScalarY(t){return this.y-=t,this}divideX(t){if(t.x===0)throw new a;return this.x/=t.x,this}divideY(t){if(t.y===0)throw new a;return this.y/=t.y,this}divide(t){if(t.x===0||t.y===0)throw new a;return this.x/=t.x,this.y/=t.y,this}divideScalar(t){if(t===0)throw new a;return this.x/=t,this.y/=t,this}divideScalarX(t){if(t===0)throw new a;return this.x/=t,this}divideScalarY(t){if(t===0)throw new a;return this.y/=t,this}multiplyX(t){return this.x*=t.x,this}multiplyY(t){return this.y*=t.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}multiplyScalarX(t){return this.x*=t,this}multiplyScalarY(t){return this.y*=t,this}invertX(){return this.x*=-1,this}invertY(){return this.y*=-1,this}invert(){return this.x*=-1,this.y*=-1,this}reflect(t){const r=t.clone().normalize();return this.subtract(r.multiplyScalar(2*this.dot(r)))}normalize(){return this.divideScalar(this.magnitude())}norm=this.normalize;clampX(t,r){const i=u(t)?t.x:h(t);if(r===void 0)return this.x=Math.min(this.x,i),this;if(typeof t!=typeof r)throw TypeError("Params must have the same type");const s=u(r)?r.x:h(r),n=Math.min(i,s),y=Math.max(i,s);return this.x=m(this.x,n,y),this}clampY(t,r){const i=u(t)?t.y:h(t);if(r===void 0)return this.y=Math.min(this.y,i),this;if(typeof t!=typeof r)throw TypeError("Params must have the same type");const s=u(r)?r.y:h(r),n=Math.min(i,s),y=Math.max(i,s);return this.y=m(this.y,n,y),this}clampMag(t,r){const i=this.mag(),s=u(t)?t.mag():h(t);if(s<0)throw RangeError("Can't clamp the magnitude to a negative value");if(r===void 0)return i>s&&this.resize(s),this;if(typeof t!=typeof r)throw TypeError("Params must have the same type");const n=u(r)?r.mag():h(r);if(n<0)throw RangeError("Can't clamp the magnitude to a negative value");const y=Math.min(s,n),f=Math.max(s,n),l=m(i,y,f);return i!==l&&this.resize(l),this}clampAxes(t,r){return this.clampX(t,r).clampY(t,r)}limitX(t,r){return Math.abs(this.x)>t&&(this.x*=r),this}limitY(t,r){return Math.abs(this.y)>t&&(this.y*=r),this}limit(t,r){return this.limitX(t,r),this.limitY(t,r),this}randomizeX(t,r){const i=Math.min(t.x,r.x),s=Math.max(t.x,r.x);return this.x=c(i,s),this}randomizeY(t,r){const i=Math.min(t.y,r.y),s=Math.max(t.y,r.y);return this.y=c(i,s),this}randomize(t,r){return this.randomizeX(t,r),this.randomizeY(t,r),this}randomizeAny(t,r){return Math.random()<.5?this.randomizeX(t,r):this.randomizeY(t,r),this}unfloat(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}fixPrecision(t=8){return this.x=Number(this.x.toFixed(t)),this.y=Number(this.y.toFixed(t)),this}mixX(t,r=.5){if(r<0||r>1)throw new RangeError("The mixFactor argument must be between 0 and 1.");return this.x=(1-r)*this.x+r*t.x,this}mixY(t,r=.5){if(r<0||r>1)throw new RangeError("The mixFactor argument must be between 0 and 1.");return this.y=(1-r)*this.y+r*t.y,this}mix(t,r=.5){if(r<0||r>1)throw new RangeError("The mixFactor argument must be between 0 and 1.");return this.mixX(t,r),this.mixY(t,r),this}clone(){return new o(this.x,this.y)}copyX(t){return this.x=t.x,this}copyY(t){return this.y=t.y,this}copy(t){return this.x=t.x,this.y=t.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}projectOnto(t){if(t.isZero())throw new a;const r=(this.x*t.x+this.y*t.y)/(t.x*t.x+t.y*t.y);return this.x=r*t.x,this.y=r*t.y,this}horizontalAngle(){return Math.atan2(this.y,this.x)}horizontalAngleDeg(){return x(this.horizontalAngle())}verticalAngle(){return Math.atan2(this.x,this.y)}verticalAngleDeg(){return x(this.verticalAngle())}angle=this.horizontalAngle;direction=this.horizontalAngle;angleDeg=this.horizontalAngleDeg;slope(){const t=this.y/this.x;return Object.is(t,-0)?0:t===-1/0?1/0:t}angleWith(t){if(this.isZero()||t.isZero())return 0;const r=(this.x*t.x+this.y*t.y)/(this.magnitude()*t.magnitude()),i=Math.max(-1,Math.min(1,r));return Math.acos(i)}angleDegWith(t){return x(this.angleWith(t))}orientedAngleWith(t){return Math.atan2(this.x*t.y-this.y*t.x,this.x*t.x+this.y*t.y)}orientedAngleDegWith(t){return x(this.orientedAngleWith(t))}rotateBy(t){const r=this.x*Math.cos(t)-this.y*Math.sin(t),i=this.x*Math.sin(t)+this.y*Math.cos(t);return this.x=r,this.y=i,this}rotateByDeg(t){const r=d(t);return this.rotateBy(r)}rotateTowards(t,r){if(r<=0)throw new RangeError("The max angle must be positive");const i=this.angleWith(t);let s=Math.min(i,r);return this.cross(t)<0&&(s=-s),this.rotateBy(s)}rotateTowardsDeg(t,r){return this.rotateTowards(t,d(r))}rotateTo(t){return this.rotateBy(t-this.horizontalAngle())}rotateToDeg(t){const r=d(t);return this.rotateTo(r)}distanceX(t){return this.x-t.x}absDistanceX(t){return Math.abs(this.distanceX(t))}distanceY(t){return this.y-t.y}absDistanceY(t){return Math.abs(this.distanceY(t))}distance(t){return Math.sqrt(this.distanceSq(t))}distanceSq(t){const r=this.distanceX(t),i=this.distanceY(t);return r*r+i*i}distanceManhattan(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}distanceChebyshev(t){return Math.max(Math.abs(this.x-t.x),Math.abs(this.y-t.y))}mag(){return Math.sqrt(this.magSq())}magnitude=this.mag;magSq(){return this.x*this.x+this.y*this.y}zero(){return this.x=0,this.y=0,this}resize(t){if(t==null)throw new TypeError("The magnitude argument must be defined");return this.normalize(),this.multiplyScalar(t),this}isParallelTo(t){return Math.abs(this.cross(t))<1e-6}isPerpendicularTo(t){return Math.abs(this.dot(t))<1e-6}isZero(){return this.x===0&&this.y===0}isEqualTo(t){return this.x===t.x&&this.y===t.y}isCloseTo(t,r=1e-6){return Math.abs(this.x-t.x)<=r&&Math.abs(this.y-t.y)<=r}toString(){return`x:${this.x}, y:${this.y}`}toArray(){return[this.x,this.y]}toObject(){return{x:this.x,y:this.y}}toPolar(){const t=Math.atan2(this.y,this.x);return{r:Math.sqrt(this.x*this.x+this.y*this.y),theta:Number.isNaN(t)?0:t}}}const g=180/Math.PI;function c(e,t){return Math.random()*(t-e)+e}function x(e){return e*g}function d(e){return e/g}export{o as V};
